def go_module_get(name:str, get:str|list, repo:str='', deps:list=[], exported_deps:list=None,
           visibility:list=None, patch:str=None, binary:bool=False, test_only:bool&testonly=False,
           install:list=None, revision:str|list=None, version:str|list=None, sum:str|list=None, strip:list=None, hashes:list=None,
           extra_outs:list=[], licences:list=None):
    """Defines a dependency on a third-party Go library.

    Note that unlike a normal `go get` call, this does *not* install transitive dependencies.
    You will need to add those as separate rules; `go list -f '{{.Deps}}' <package>` can be
    useful to discover what they should be.

    Note also that while a single go_get is sufficient to compile all parts of a library,
    one may also want separate ones for a binary. Since two rules can't both output the same
    source files (and you only want to download them once anyway) you should handle that by
    marking the non-binary rule as a dependency of the binary one - if you don't there may
    be warnings issued about conflicting output files.

    Args:
      name (str): Name of the rule
      get (str): Target to get (eg. "github.com/gorilla/mux"). Can also be a list of multiple in
                 which case they are fetched separately and compiled together, which can be useful
                 for avoiding issues with circular dependencies.
      repo (str): Location of a Git repository to fetch from.
      deps (list): Dependencies
      exported_deps (list): Dependencies to make available to anything using this rule.
      visibility (list): Visibility specification
      patch (str): Patch file to apply
      binary (bool): True if the output of the rule is a binary.
      test_only (bool): If true this rule will only be visible to tests.
      install (list): Allows specifying the exact list of packages to install. If this is not passed,
                      the package passed to 'get' is installed. If you pass this for subpackages, you
                      will need to explicitly add an empty string to the list if you want to install
                      the root package from this repo.
      revision (str): Git hash to check out before building. Only works for git at present,
                      not for other version control systems.
      version (str): Go module version (enabling module mode).
      sum (str): Go module hash (required when version is passed).
      strip (list): List of paths to strip from the installed target.
      hashes (list): List of hashes to verify the downloaded sources against.
      extra_outs (list): List of additional output files after the compile.
      licences (list): Licences this rule is subject to.
    """
    if isinstance(get, str):
        get = [get]
        revision = [revision]
        version = [version]
        sum = [sum]
        tags = ['get']
    else:
        tags = [basename(dirname(g)) for g in get]
        revision = revision or [None for g in get]
        version = version or [None for g in get]
        sum = sum or [None for g in get]
    all_installs = []
    outs = extra_outs
    provides = None
    srcs = []
    for getone, revision, version, sum, tag in zip(get, revision, version, sum, tags):
        get_rule, getroot = _go_get_download(
            name = name,
            tag = tag,
            get = getone,
            repo = repo,
            patch = patch,
            hashes = hashes,
            test_only = test_only,
            revision = revision,
            version = version,
            sum = sum,
            strip = strip,
            licences = licences,
        )
        outs += [getroot]
        srcs += [get_rule]
        provides = {'go': ':' + name, 'go_src': get_rule}
        if install:
            all_installs += [i if i.startswith(getroot) else (getroot + '/' + i) for i in install]
        else:
            all_installs += [getone]

    # Now compile it in a separate step.
    cmd = [
        'export GOPATH="$(find \"$TMP_DIR\" \( -name src -o -name pkg \) -exec dirname {} \; | sort | uniq | tr \'\\n\' \':\' | sed \'s/:$//\')" GO111MODULE="off"',
        '"$TOOLS_GO" install ' + ' '.join(all_installs or install),
    ]
    if package_name():
        cmd += [
            # The outputs tend to end up in subdirectories (Go seems to match them to the location the source came from)
            'rm -rf bin' if binary else 'rm -rf pkg',
            'mv "$PKG_DIR/bin" .' if binary else 'mv "$PKG_DIR/pkg" .',
        ]
    if binary:
        outs = ['bin/' + name]
    else:
        outs = [f'pkg/{CONFIG.GOOS}_{CONFIG.GOARCH}/{out}' for out in outs]
        # Outputs are created one directory down from where we want them.
        # For most it doesn't matter but the top-level one will get lost.
        cmd += [f' if [ -f {out}.a ]; then mkdir -p {out} && mv {out}.a {out}; fi' for out in outs]
    return build_rule(
        name = name,
        outs = outs,
        deps = deps,
        srcs = srcs,
        exported_deps = exported_deps,
        tools = {
            'go': [CONFIG.GO_TOOL],
        },
        visibility = visibility,
        building_description = 'Compiling...',
        cmd = ' && '.join(cmd),
        binary = binary,
        requires = ['go', 'go_src'],
        test_only = test_only,
        labels = ['link:plz-out/go'],
        sandbox = False,
        needs_transitive_deps = True,
        provides = provides,
        licences = licences,
    )


def _go_get_download(name:str, tag:str, get:str, repo:str='', patch:str=None, hashes:list=None,
                     test_only:bool&testonly=False, revision:str=None, version:str=None, sum:str=None, strip:list=None,
                     labels:list=[], licences:list=None):
    if hashes and not revision:
        log.warning("You shouldn't specify hashes on go_get without specifying revision as well")

    assert not(revision and version), "Must not pass both 'revision' and version"

    if version:
        assert sum, "Must pass 'sum' when module mode is used ('version' is passed)"

    version_label = revision if revision else version

    labels = [f'go_get:{get}@{version_label}' if version_label else f'go_get:{get}']
    getroot = get[:-4] if get.endswith('/...') else get
    subdir = 'src/' + getroot
    revision = revision or 'master'

    tools = {
        'go': [CONFIG.GO_TOOL]
    }

    if version:
        tools['fetch_repo'] = ["//cmd/fetch_repo"]

        get_deps = []

        # TODO: add support for replacing modules
        cmd = [
            'export GOSUMDB=off', # Disable sumdb in fetch_repo. In module mode, the sum is a mandatory attribute of go_repository, so we don't need to look it up.
            'export GO111MODULE=on', # Needed by module mode.
            f'mkdir -p src/{getroot}', # Bug in fetch_repo?
            f'$TOOLS_FETCH_REPO -dest src/{getroot} -importpath={getroot} -version={version} -sum={sum}',
        ]
    else:
        # Some special optimisation for github, which lets us download zipfiles at a particular sha instead of
        # cloning the whole repo. Obviously that is a lot faster than cloning entire repos.
        if repo.startswith('github.com'):
                cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, repo, revision)
        elif get.startswith('github.com'):
            cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, getroot, revision)
        elif get.startswith('golang.org/x/') and not repo:
            # We know about these guys...
            cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, 'github.com/golang/' + getroot[len('golang.org/x/'):], revision)
        elif get.startswith('google.golang.org/grpc') and not repo:
            cmd, get_deps, tools = _go_github_repo_cmd(name, getroot, 'github.com/grpc/grpc-go' + getroot[len('google.golang.org/grpc'):], revision)
        else:
            get_deps = []
            if repo:
                # we've been told exactly where to get the source from.
                cmd = [f'git clone --branch {revision} --depth=1 --shallow-submodules --no-tags {repo} src/{getroot}']
            else:
                # Ultimate fallback to go get.
                # This has some more restrictions than the above (e.g. go get won't fetch a directory
                # with no Go files in it, even if passed -d).
                cmd = [
                    'rm -rf src pkg',
                    'export GOPATH="$TMP_DIR" GO111MODULE="off"',
                    '$TOOLS_GO get -d ' + get,
                ]
            if revision:
                # Annoyingly -C does not work on git checkout :(
                cmd += [f'(cd {subdir} && git checkout -q {revision})']
            cmd += ['find . -name .git | xargs rm -rf']
            #tools = [CONFIG.GO_TOOL]
    if patch:
        cmd += [f'patch -s -d {subdir} -p1 < "$TMP_DIR"/$SRCS_PATCH']
    if strip:
        cmd += [f'rm -rf {subdir}/{s}' for s in strip]
    return build_rule(
        name = name,
        tag = tag,
        srcs = {
            'patch': [patch],
            'get': get_deps,
        },
        outs = [subdir],
        tools = tools,
        building_description = 'Fetching...',
        cmd = ' && '.join(cmd),
        requires = ['go'],
        test_only = test_only,
        labels = labels + ['link:plz-out/go'],
        hashes = hashes,
        sandbox = False,
        licences = licences,
    ), getroot
